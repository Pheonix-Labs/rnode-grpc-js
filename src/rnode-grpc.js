import * as R from 'ramda'
import { protoTsTypesMapping, flattenSchema } from './lib'

const { log, warn } = console

const init = ({protoSchema}) => {
  const schemaFlat = R.chain(flattenSchema([]), [protoSchema])
  const isType = ({type}) => type === 'type'
  const isName = typeName => ({name}) => name === typeName
  const types = R.filter(isType, schemaFlat)
  // Returns type definition and type constructor (protoc generated)
  const getType = name => {
    const typeDef = R.find(isName(name), types)
    const { namespace } = typeDef
    const typePath = R.lensPath([...namespace, name])
    // Get type constructor from `proto` global object generated by `protoc` tool
    return {
      constructor: R.view(typePath, proto),
      def: typeDef,
    }
  }
  // Methods defined in protobufjs generated JSON schema
  const methods = R.pipe(
    R.filter(R.propEq('type', 'service')),
    R.map(R.prop('methods')),
    R.mergeAll,
  )(schemaFlat)

  return { getType, methods, types }
}

const resolveEither = eitherMsg => {
  const { success, error } = eitherMsg.toObject()
  if (success) {
    const {value: valBytes, typeUrl} = success.response
    const [_, typeFullName] = typeUrl.match(/^type.rchain.coop\/(.+)$/)
    const typeLens = R.lensPath(typeFullName.split('.'))
    // Get type constructor from `proto` global object generated by `protoc` tool
    const typeDef = R.view(typeLens, proto)
    // Deserialize message and convert to JS object
    return typeDef.deserializeBinary(valBytes).toObject()
  } else if (error) {
    const { messagesList } = error

    throw Error(`Either error: ${messagesList.join(', ')}`)
  }
}

const responseToObject = (responseType, msg) =>
  responseType === 'Either' ? resolveEither(msg) : msg.toObject()

const simpleTypes = R.map(R.prop('proto'), protoTsTypesMapping)

const fillObject = R.curry((getType, reqTypeName, input) => {
  const type = getType(reqTypeName)
  if (!type) throw Error(`Request type not found: ${reqTypeName}`)
  const req = new type.constructor()
  Object.entries(input || {}).forEach(([k, v]) => {
    const genKey = k.replace(/_(\S)/g, (_, x) => x.toUpperCase())
    const field = type.def.fields[genKey]
    if (!field) {
      warn(`Property not found: ${reqTypeName}.${k}`)
      return
    }

    // Handle collections (proto repeated)
    const isListType = field.rule === 'repeated'
    const setterSuffix = isListType ? `List` : ''
    const [fst, snd, ...tail] = genKey
    const setterName = f => R.flatten(
      ['set', fst.toUpperCase(), snd, f(tail.join('')), setterSuffix]
    ).join('')
    const setter = req[setterName(R.identity)] || req[setterName(R.toLower)]
    !setter && warn(
      `Property setter not found ${reqTypeName}.${k} (<gen-js>.${setterName(R.identity)})`
    )

    // Create property value / recursively resolve complex types
    const val =
      ~simpleTypes.indexOf(field.type)
        // Simple type
        ? v
        // Complex type
        : isListType
          ? R.map(fillObject(getType, field.type), v)
          : fillObject(getType, field.type, v)

    // Set property value
    setter.bind(req)(val)
  })
  return req
})

const createApiMethod = R.curry((service, getType, method, name) => async (input, meta) => {
  const isReponseStream = !!method.responseStream
  const req = fillObject(getType, method.requestType, input)

  // Get service method
  const lowerize = ([h, ...t]) => `${h.toLowerCase()}${t.join('')}`
  const sm = service[name] || service[lowerize(name)]
  if (!sm) throw Error(`Service method not found: ${name}`)
  const serviceMethod = sm.bind(service)

  if (isReponseStream) {
    const call = serviceMethod(req, meta)
    const streamResult = []
    return new Promise((resolve, reject) => {
      call.on('data', resultMsg => {
        try {
          const result = responseToObject(method.responseType, resultMsg)
          streamResult.push(result)
        } catch (err) { reject(err) }
      })
      call.on('error', reject)
      call.on('end', _ => { resolve(streamResult) })
    })
  } else {
    return new Promise((resolve, reject) => {
      serviceMethod(req, meta, (err, resultMsg) => {
        if (err) reject(err)
        else {
          try {
            // Resolve Either value
            const result = responseToObject(method.responseType, resultMsg)
            resolve(result)
          } catch (err) { reject(err) }
        }
      })
    })
  }
})

export const rnodeService = (service, opt) => {
  const {getType, methods} = init(opt)

  // Create RNode service API from proto definition
  return R.mapObjIndexed(
    createApiMethod(service, getType),
    methods,
  )
}

// Different name for each service to support TypeScript definitions
export const rnodeDeploy  = rnodeService
export const rnodePropose = rnodeService
export const rnodeRepl    = rnodeService

export const rnodeProtobuf = ({protoSchema}) => {
  const {getType, types} = init({protoSchema})

  const getTypeOp = ({name}) => {
    const {def, constructor} = getType(name)
    const serialize = obj => {
      const t = fillObject(getType, name, obj)
      return t.serializeBinary() /* Uint8Array */
    }
    const deserialize = bytes => {
      const msg = constructor.deserializeBinary(bytes)
      return msg.toObject()
    }
    const create = opt => {
      return new constructor(opt)
    }
    return { [name]: { serialize, deserialize, create } }
  }

  return R.pipe(
    R.map(getTypeOp),
    R.mergeAll,
  )(types)
}
